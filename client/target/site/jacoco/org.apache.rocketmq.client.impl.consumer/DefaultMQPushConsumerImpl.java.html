<?xml version="1.0" encoding="UTF-8"?><!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Strict//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-strict.dtd"><html xmlns="http://www.w3.org/1999/xhtml" lang="zh"><head><meta http-equiv="Content-Type" content="text/html;charset=UTF-8"/><link rel="stylesheet" href="../jacoco-resources/report.css" type="text/css"/><link rel="shortcut icon" href="../jacoco-resources/report.gif" type="image/gif"/><title>DefaultMQPushConsumerImpl.java</title><link rel="stylesheet" href="../jacoco-resources/prettify.css" type="text/css"/><script type="text/javascript" src="../jacoco-resources/prettify.js"></script></head><body onload="window['PR_TAB_WIDTH']=4;prettyPrint()"><div class="breadcrumb" id="breadcrumb"><span class="info"><a href="../jacoco-sessions.html" class="el_session">Sessions</a></span><a href="../index.html" class="el_report">rocketmq-client 4.8.0</a> &gt; <a href="index.source.html" class="el_package">org.apache.rocketmq.client.impl.consumer</a> &gt; <span class="el_source">DefaultMQPushConsumerImpl.java</span></div><h1>DefaultMQPushConsumerImpl.java</h1><pre class="source lang-java linenums">/*
 * Licensed to the Apache Software Foundation (ASF) under one or more
 * contributor license agreements.  See the NOTICE file distributed with
 * this work for additional information regarding copyright ownership.
 * The ASF licenses this file to You under the Apache License, Version 2.0
 * (the &quot;License&quot;); you may not use this file except in compliance with
 * the License.  You may obtain a copy of the License at
 *
 *     http://www.apache.org/licenses/LICENSE-2.0
 *
 * Unless required by applicable law or agreed to in writing, software
 * distributed under the License is distributed on an &quot;AS IS&quot; BASIS,
 * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
 * See the License for the specific language governing permissions and
 * limitations under the License.
 */
package org.apache.rocketmq.client.impl.consumer;

import java.util.ArrayList;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Properties;
import java.util.Set;
import java.util.concurrent.ConcurrentMap;

import org.apache.commons.lang3.StringUtils;
import org.apache.rocketmq.client.QueryResult;
import org.apache.rocketmq.client.Validators;
import org.apache.rocketmq.client.consumer.DefaultMQPushConsumer;
import org.apache.rocketmq.client.consumer.MessageSelector;
import org.apache.rocketmq.client.consumer.PullCallback;
import org.apache.rocketmq.client.consumer.PullResult;
import org.apache.rocketmq.client.consumer.listener.MessageListener;
import org.apache.rocketmq.client.consumer.listener.MessageListenerConcurrently;
import org.apache.rocketmq.client.consumer.listener.MessageListenerOrderly;
import org.apache.rocketmq.client.consumer.store.LocalFileOffsetStore;
import org.apache.rocketmq.client.consumer.store.OffsetStore;
import org.apache.rocketmq.client.consumer.store.ReadOffsetType;
import org.apache.rocketmq.client.consumer.store.RemoteBrokerOffsetStore;
import org.apache.rocketmq.client.exception.MQBrokerException;
import org.apache.rocketmq.client.exception.MQClientException;
import org.apache.rocketmq.client.hook.ConsumeMessageContext;
import org.apache.rocketmq.client.hook.ConsumeMessageHook;
import org.apache.rocketmq.client.hook.FilterMessageHook;
import org.apache.rocketmq.client.impl.CommunicationMode;
import org.apache.rocketmq.client.impl.MQClientManager;
import org.apache.rocketmq.client.impl.factory.MQClientInstance;
import org.apache.rocketmq.client.log.ClientLogger;
import org.apache.rocketmq.client.stat.ConsumerStatsManager;
import org.apache.rocketmq.common.MixAll;
import org.apache.rocketmq.common.ServiceState;
import org.apache.rocketmq.common.UtilAll;
import org.apache.rocketmq.common.consumer.ConsumeFromWhere;
import org.apache.rocketmq.common.filter.FilterAPI;
import org.apache.rocketmq.common.help.FAQUrl;
import org.apache.rocketmq.common.protocol.NamespaceUtil;
import org.apache.rocketmq.logging.InternalLogger;
import org.apache.rocketmq.common.message.Message;
import org.apache.rocketmq.common.message.MessageAccessor;
import org.apache.rocketmq.common.message.MessageConst;
import org.apache.rocketmq.common.message.MessageExt;
import org.apache.rocketmq.common.message.MessageQueue;
import org.apache.rocketmq.common.protocol.body.ConsumeStatus;
import org.apache.rocketmq.common.protocol.body.ConsumerRunningInfo;
import org.apache.rocketmq.common.protocol.body.ProcessQueueInfo;
import org.apache.rocketmq.common.protocol.body.QueueTimeSpan;
import org.apache.rocketmq.common.protocol.heartbeat.ConsumeType;
import org.apache.rocketmq.common.protocol.heartbeat.MessageModel;
import org.apache.rocketmq.common.protocol.heartbeat.SubscriptionData;
import org.apache.rocketmq.common.protocol.route.BrokerData;
import org.apache.rocketmq.common.protocol.route.TopicRouteData;
import org.apache.rocketmq.common.sysflag.PullSysFlag;
import org.apache.rocketmq.remoting.RPCHook;
import org.apache.rocketmq.remoting.common.RemotingHelper;
import org.apache.rocketmq.remoting.exception.RemotingException;

public class DefaultMQPushConsumerImpl implements MQConsumerInner {
    /**
     * Delay some time when exception occur
     */
<span class="fc" id="L86">    private long pullTimeDelayMillsWhenException = 3000;</span>
    /**
     * Flow control interval
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL = 50;
    /**
     * Delay some time when suspend pull service
     */
    private static final long PULL_TIME_DELAY_MILLS_WHEN_SUSPEND = 1000;
    private static final long BROKER_SUSPEND_MAX_TIME_MILLIS = 1000 * 15;
    private static final long CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND = 1000 * 30;
<span class="fc" id="L97">    private final InternalLogger log = ClientLogger.getLog();</span>
    private final DefaultMQPushConsumer defaultMQPushConsumer;
<span class="fc" id="L99">    private final RebalanceImpl rebalanceImpl = new RebalancePushImpl(this);</span>
<span class="fc" id="L100">    private final ArrayList&lt;FilterMessageHook&gt; filterMessageHookList = new ArrayList&lt;FilterMessageHook&gt;();</span>
<span class="fc" id="L101">    private final long consumerStartTimestamp = System.currentTimeMillis();</span>
<span class="fc" id="L102">    private final ArrayList&lt;ConsumeMessageHook&gt; consumeMessageHookList = new ArrayList&lt;ConsumeMessageHook&gt;();</span>
    private final RPCHook rpcHook;
<span class="fc" id="L104">    private volatile ServiceState serviceState = ServiceState.CREATE_JUST;</span>
    private MQClientInstance mQClientFactory;
    private PullAPIWrapper pullAPIWrapper;
<span class="fc" id="L107">    private volatile boolean pause = false;</span>
<span class="fc" id="L108">    private boolean consumeOrderly = false;</span>
    private MessageListener messageListenerInner;
    private OffsetStore offsetStore;
    private ConsumeMessageService consumeMessageService;
<span class="fc" id="L112">    private long queueFlowControlTimes = 0;</span>
<span class="fc" id="L113">    private long queueMaxSpanFlowControlTimes = 0;</span>

<span class="fc" id="L115">    public DefaultMQPushConsumerImpl(DefaultMQPushConsumer defaultMQPushConsumer, RPCHook rpcHook) {</span>
<span class="fc" id="L116">        this.defaultMQPushConsumer = defaultMQPushConsumer;</span>
<span class="fc" id="L117">        this.rpcHook = rpcHook;</span>
<span class="fc" id="L118">        this.pullTimeDelayMillsWhenException = defaultMQPushConsumer.getPullTimeDelayMillsWhenException();</span>
<span class="fc" id="L119">    }</span>

    public void registerFilterMessageHook(final FilterMessageHook hook) {
<span class="nc" id="L122">        this.filterMessageHookList.add(hook);</span>
<span class="nc" id="L123">        log.info(&quot;register FilterMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L124">    }</span>

    public boolean hasHook() {
<span class="nc bnc" id="L127" title="All 2 branches missed.">        return !this.consumeMessageHookList.isEmpty();</span>
    }

    public void registerConsumeMessageHook(final ConsumeMessageHook hook) {
<span class="nc" id="L131">        this.consumeMessageHookList.add(hook);</span>
<span class="nc" id="L132">        log.info(&quot;register consumeMessageHook Hook, {}&quot;, hook.hookName());</span>
<span class="nc" id="L133">    }</span>

    public void executeHookBefore(final ConsumeMessageContext context) {
<span class="nc bnc" id="L136" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L137" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L139">                    hook.consumeMessageBefore(context);</span>
<span class="nc" id="L140">                } catch (Throwable e) {</span>
<span class="nc" id="L141">                }</span>
<span class="nc" id="L142">            }</span>
        }
<span class="nc" id="L144">    }</span>

    public void executeHookAfter(final ConsumeMessageContext context) {
<span class="nc bnc" id="L147" title="All 2 branches missed.">        if (!this.consumeMessageHookList.isEmpty()) {</span>
<span class="nc bnc" id="L148" title="All 2 branches missed.">            for (ConsumeMessageHook hook : this.consumeMessageHookList) {</span>
                try {
<span class="nc" id="L150">                    hook.consumeMessageAfter(context);</span>
<span class="nc" id="L151">                } catch (Throwable e) {</span>
<span class="nc" id="L152">                }</span>
<span class="nc" id="L153">            }</span>
        }
<span class="nc" id="L155">    }</span>

    public void createTopic(String key, String newTopic, int queueNum) throws MQClientException {
<span class="nc" id="L158">        createTopic(key, newTopic, queueNum, 0);</span>
<span class="nc" id="L159">    }</span>

    public void createTopic(String key, String newTopic, int queueNum, int topicSysFlag) throws MQClientException {
<span class="nc" id="L162">        this.mQClientFactory.getMQAdminImpl().createTopic(key, newTopic, queueNum, topicSysFlag);</span>
<span class="nc" id="L163">    }</span>

    public Set&lt;MessageQueue&gt; fetchSubscribeMessageQueues(String topic) throws MQClientException {
<span class="nc" id="L166">        Set&lt;MessageQueue&gt; result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc bnc" id="L167" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L168">            this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="nc" id="L169">            result = this.rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
        }

<span class="nc bnc" id="L172" title="All 2 branches missed.">        if (null == result) {</span>
<span class="nc" id="L173">            throw new MQClientException(&quot;The topic[&quot; + topic + &quot;] not exist&quot;, null);</span>
        }

<span class="nc" id="L176">        return parseSubscribeMessageQueues(result);</span>
    }

    public Set&lt;MessageQueue&gt; parseSubscribeMessageQueues(Set&lt;MessageQueue&gt; messageQueueList) {
<span class="nc" id="L180">        Set&lt;MessageQueue&gt; resultQueues = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc bnc" id="L181" title="All 2 branches missed.">        for (MessageQueue queue : messageQueueList) {</span>
<span class="nc" id="L182">            String userTopic = NamespaceUtil.withoutNamespace(queue.getTopic(), this.defaultMQPushConsumer.getNamespace());</span>
<span class="nc" id="L183">            resultQueues.add(new MessageQueue(userTopic, queue.getBrokerName(), queue.getQueueId()));</span>
<span class="nc" id="L184">        }</span>

<span class="nc" id="L186">        return resultQueues;</span>
    }

    public DefaultMQPushConsumer getDefaultMQPushConsumer() {
<span class="fc" id="L190">        return defaultMQPushConsumer;</span>
    }

    public long earliestMsgStoreTime(MessageQueue mq) throws MQClientException {
<span class="nc" id="L194">        return this.mQClientFactory.getMQAdminImpl().earliestMsgStoreTime(mq);</span>
    }

    public long maxOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L198">        return this.mQClientFactory.getMQAdminImpl().maxOffset(mq);</span>
    }

    public long minOffset(MessageQueue mq) throws MQClientException {
<span class="nc" id="L202">        return this.mQClientFactory.getMQAdminImpl().minOffset(mq);</span>
    }

    public OffsetStore getOffsetStore() {
<span class="fc" id="L206">        return offsetStore;</span>
    }

    public void setOffsetStore(OffsetStore offsetStore) {
<span class="nc" id="L210">        this.offsetStore = offsetStore;</span>
<span class="nc" id="L211">    }</span>

    public void pullMessage(final PullRequest pullRequest) {
<span class="nc" id="L214">        final ProcessQueue processQueue = pullRequest.getProcessQueue();</span>
<span class="nc bnc" id="L215" title="All 2 branches missed.">        if (processQueue.isDropped()) {</span>
<span class="nc" id="L216">            log.info(&quot;the pull request[{}] is dropped.&quot;, pullRequest.toString());</span>
<span class="nc" id="L217">            return;</span>
        }

<span class="nc" id="L220">        pullRequest.getProcessQueue().setLastPullTimestamp(System.currentTimeMillis());</span>

        try {
<span class="nc" id="L223">            this.makeSureStateOK();</span>
<span class="nc" id="L224">        } catch (MQClientException e) {</span>
<span class="nc" id="L225">            log.warn(&quot;pullMessage exception, consumer state not ok&quot;, e);</span>
<span class="nc" id="L226">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L227">            return;</span>
<span class="nc" id="L228">        }</span>

<span class="nc bnc" id="L230" title="All 2 branches missed.">        if (this.isPause()) {</span>
<span class="nc" id="L231">            log.warn(&quot;consumer was paused, execute pull request later. instanceName={}, group={}&quot;, this.defaultMQPushConsumer.getInstanceName(), this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L232">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_SUSPEND);</span>
<span class="nc" id="L233">            return;</span>
        }

<span class="nc" id="L236">        long cachedMessageCount = processQueue.getMsgCount().get();</span>
<span class="nc" id="L237">        long cachedMessageSizeInMiB = processQueue.getMsgSize().get() / (1024 * 1024);</span>

<span class="nc bnc" id="L239" title="All 2 branches missed.">        if (cachedMessageCount &gt; this.defaultMQPushConsumer.getPullThresholdForQueue()) {</span>
<span class="nc" id="L240">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L241" title="All 2 branches missed.">            if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L242">                log.warn(</span>
                    &quot;the cached message count exceeds the threshold {}, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L244">                    this.defaultMQPushConsumer.getPullThresholdForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span>
            }
<span class="nc" id="L246">            return;</span>
        }

<span class="nc bnc" id="L249" title="All 2 branches missed.">        if (cachedMessageSizeInMiB &gt; this.defaultMQPushConsumer.getPullThresholdSizeForQueue()) {</span>
<span class="nc" id="L250">            this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L251" title="All 2 branches missed.">            if ((queueFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L252">                log.warn(</span>
                    &quot;the cached message size exceeds the threshold {} MiB, so do flow control, minOffset={}, maxOffset={}, count={}, size={} MiB, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L254">                    this.defaultMQPushConsumer.getPullThresholdSizeForQueue(), processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), cachedMessageCount, cachedMessageSizeInMiB, pullRequest, queueFlowControlTimes);</span>
            }
<span class="nc" id="L256">            return;</span>
        }

<span class="nc bnc" id="L259" title="All 2 branches missed.">        if (!this.consumeOrderly) {</span>
<span class="nc bnc" id="L260" title="All 2 branches missed.">            if (processQueue.getMaxSpan() &gt; this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan()) {</span>
<span class="nc" id="L261">                this.executePullRequestLater(pullRequest, PULL_TIME_DELAY_MILLS_WHEN_FLOW_CONTROL);</span>
<span class="nc bnc" id="L262" title="All 2 branches missed.">                if ((queueMaxSpanFlowControlTimes++ % 1000) == 0) {</span>
<span class="nc" id="L263">                    log.warn(</span>
                        &quot;the queue's messages, span too long, so do flow control, minOffset={}, maxOffset={}, maxSpan={}, pullRequest={}, flowControlTimes={}&quot;,
<span class="nc" id="L265">                        processQueue.getMsgTreeMap().firstKey(), processQueue.getMsgTreeMap().lastKey(), processQueue.getMaxSpan(),</span>
<span class="nc" id="L266">                        pullRequest, queueMaxSpanFlowControlTimes);</span>
                }
<span class="nc" id="L268">                return;</span>
            }
        } else {
<span class="nc bnc" id="L271" title="All 2 branches missed.">            if (processQueue.isLocked()) {</span>
<span class="nc bnc" id="L272" title="All 2 branches missed.">                if (!pullRequest.isLockedFirst()) {</span>
<span class="nc" id="L273">                    final long offset = this.rebalanceImpl.computePullFromWhere(pullRequest.getMessageQueue());</span>
<span class="nc bnc" id="L274" title="All 2 branches missed.">                    boolean brokerBusy = offset &lt; pullRequest.getNextOffset();</span>
<span class="nc" id="L275">                    log.info(&quot;the first time to pull message, so fix offset from broker. pullRequest: {} NewOffset: {} brokerBusy: {}&quot;,</span>
<span class="nc" id="L276">                        pullRequest, offset, brokerBusy);</span>
<span class="nc bnc" id="L277" title="All 2 branches missed.">                    if (brokerBusy) {</span>
<span class="nc" id="L278">                        log.info(&quot;[NOTIFYME]the first time to pull message, but pull request offset larger than broker consume offset. pullRequest: {} NewOffset: {}&quot;,</span>
<span class="nc" id="L279">                            pullRequest, offset);</span>
                    }

<span class="nc" id="L282">                    pullRequest.setLockedFirst(true);</span>
<span class="nc" id="L283">                    pullRequest.setNextOffset(offset);</span>
<span class="nc" id="L284">                }</span>
            } else {
<span class="nc" id="L286">                this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L287">                log.info(&quot;pull message later because not locked in broker, {}&quot;, pullRequest);</span>
<span class="nc" id="L288">                return;</span>
            }
        }

<span class="nc" id="L292">        final SubscriptionData subscriptionData = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="nc bnc" id="L293" title="All 2 branches missed.">        if (null == subscriptionData) {</span>
<span class="nc" id="L294">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L295">            log.warn(&quot;find the consumer's subscription failed, {}&quot;, pullRequest);</span>
<span class="nc" id="L296">            return;</span>
        }

<span class="nc" id="L299">        final long beginTimestamp = System.currentTimeMillis();</span>

<span class="nc" id="L301">        PullCallback pullCallback = new PullCallback() {</span>
            @Override
            public void onSuccess(PullResult pullResult) {
<span class="nc bnc" id="L304" title="All 2 branches missed.">                if (pullResult != null) {</span>
<span class="nc" id="L305">                    pullResult = DefaultMQPushConsumerImpl.this.pullAPIWrapper.processPullResult(pullRequest.getMessageQueue(), pullResult,</span>
                        subscriptionData);

<span class="nc bnc" id="L308" title="All 4 branches missed.">                    switch (pullResult.getPullStatus()) {</span>
                        case FOUND:
<span class="nc" id="L310">                            long prevRequestOffset = pullRequest.getNextOffset();</span>
<span class="nc" id="L311">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>
<span class="nc" id="L312">                            long pullRT = System.currentTimeMillis() - beginTimestamp;</span>
<span class="nc" id="L313">                            DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullRT(pullRequest.getConsumerGroup(),</span>
<span class="nc" id="L314">                                pullRequest.getMessageQueue().getTopic(), pullRT);</span>

<span class="nc" id="L316">                            long firstMsgOffset = Long.MAX_VALUE;</span>
<span class="nc bnc" id="L317" title="All 4 branches missed.">                            if (pullResult.getMsgFoundList() == null || pullResult.getMsgFoundList().isEmpty()) {</span>
<span class="nc" id="L318">                                DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                            } else {
<span class="nc" id="L320">                                firstMsgOffset = pullResult.getMsgFoundList().get(0).getQueueOffset();</span>

<span class="nc" id="L322">                                DefaultMQPushConsumerImpl.this.getConsumerStatsManager().incPullTPS(pullRequest.getConsumerGroup(),</span>
<span class="nc" id="L323">                                    pullRequest.getMessageQueue().getTopic(), pullResult.getMsgFoundList().size());</span>

<span class="nc" id="L325">                                boolean dispatchToConsume = processQueue.putMessage(pullResult.getMsgFoundList());</span>
<span class="nc" id="L326">                                DefaultMQPushConsumerImpl.this.consumeMessageService.submitConsumeRequest(</span>
<span class="nc" id="L327">                                    pullResult.getMsgFoundList(),</span>
                                    processQueue,
<span class="nc" id="L329">                                    pullRequest.getMessageQueue(),</span>
                                    dispatchToConsume);

<span class="nc bnc" id="L332" title="All 2 branches missed.">                                if (DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval() &gt; 0) {</span>
<span class="nc" id="L333">                                    DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest,</span>
<span class="nc" id="L334">                                        DefaultMQPushConsumerImpl.this.defaultMQPushConsumer.getPullInterval());</span>
                                } else {
<span class="nc" id="L336">                                    DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
                                }
                            }

<span class="nc bnc" id="L340" title="All 4 branches missed.">                            if (pullResult.getNextBeginOffset() &lt; prevRequestOffset</span>
                                || firstMsgOffset &lt; prevRequestOffset) {
<span class="nc" id="L342">                                log.warn(</span>
                                    &quot;[BUG] pull message result maybe data wrong, nextBeginOffset: {} firstMsgOffset: {} prevRequestOffset: {}&quot;,
<span class="nc" id="L344">                                    pullResult.getNextBeginOffset(),</span>
<span class="nc" id="L345">                                    firstMsgOffset,</span>
<span class="nc" id="L346">                                    prevRequestOffset);</span>
                            }

                            break;
                        case NO_NEW_MSG:
                        case NO_MATCHED_MSG:
<span class="nc" id="L352">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L354">                            DefaultMQPushConsumerImpl.this.correctTagsOffset(pullRequest);</span>

<span class="nc" id="L356">                            DefaultMQPushConsumerImpl.this.executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L357">                            break;</span>
                        case OFFSET_ILLEGAL:
<span class="nc" id="L359">                            log.warn(&quot;the pull request offset illegal, {} {}&quot;,</span>
<span class="nc" id="L360">                                pullRequest.toString(), pullResult.toString());</span>
<span class="nc" id="L361">                            pullRequest.setNextOffset(pullResult.getNextBeginOffset());</span>

<span class="nc" id="L363">                            pullRequest.getProcessQueue().setDropped(true);</span>
<span class="nc" id="L364">                            DefaultMQPushConsumerImpl.this.executeTaskLater(new Runnable() {</span>

                                @Override
                                public void run() {
                                    try {
<span class="nc" id="L369">                                        DefaultMQPushConsumerImpl.this.offsetStore.updateOffset(pullRequest.getMessageQueue(),</span>
<span class="nc" id="L370">                                            pullRequest.getNextOffset(), false);</span>

<span class="nc" id="L372">                                        DefaultMQPushConsumerImpl.this.offsetStore.persist(pullRequest.getMessageQueue());</span>

<span class="nc" id="L374">                                        DefaultMQPushConsumerImpl.this.rebalanceImpl.removeProcessQueue(pullRequest.getMessageQueue());</span>

<span class="nc" id="L376">                                        log.warn(&quot;fix the pull request offset, {}&quot;, pullRequest);</span>
<span class="nc" id="L377">                                    } catch (Throwable e) {</span>
<span class="nc" id="L378">                                        log.error(&quot;executeTaskLater Exception&quot;, e);</span>
<span class="nc" id="L379">                                    }</span>
<span class="nc" id="L380">                                }</span>
                            }, 10000);
<span class="nc" id="L382">                            break;</span>
                        default:
                            break;
                    }
                }
<span class="nc" id="L387">            }</span>

            @Override
            public void onException(Throwable e) {
<span class="nc bnc" id="L391" title="All 2 branches missed.">                if (!pullRequest.getMessageQueue().getTopic().startsWith(MixAll.RETRY_GROUP_TOPIC_PREFIX)) {</span>
<span class="nc" id="L392">                    log.warn(&quot;execute the pull request exception&quot;, e);</span>
                }

<span class="nc" id="L395">                DefaultMQPushConsumerImpl.this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L396">            }</span>
        };

<span class="nc" id="L399">        boolean commitOffsetEnable = false;</span>
<span class="nc" id="L400">        long commitOffsetValue = 0L;</span>
<span class="nc bnc" id="L401" title="All 2 branches missed.">        if (MessageModel.CLUSTERING == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="nc" id="L402">            commitOffsetValue = this.offsetStore.readOffset(pullRequest.getMessageQueue(), ReadOffsetType.READ_FROM_MEMORY);</span>
<span class="nc bnc" id="L403" title="All 2 branches missed.">            if (commitOffsetValue &gt; 0) {</span>
<span class="nc" id="L404">                commitOffsetEnable = true;</span>
            }
        }

<span class="nc" id="L408">        String subExpression = null;</span>
<span class="nc" id="L409">        boolean classFilter = false;</span>
<span class="nc" id="L410">        SubscriptionData sd = this.rebalanceImpl.getSubscriptionInner().get(pullRequest.getMessageQueue().getTopic());</span>
<span class="nc bnc" id="L411" title="All 2 branches missed.">        if (sd != null) {</span>
<span class="nc bnc" id="L412" title="All 4 branches missed.">            if (this.defaultMQPushConsumer.isPostSubscriptionWhenPull() &amp;&amp; !sd.isClassFilterMode()) {</span>
<span class="nc" id="L413">                subExpression = sd.getSubString();</span>
            }

<span class="nc" id="L416">            classFilter = sd.isClassFilterMode();</span>
        }

<span class="nc bnc" id="L419" title="All 2 branches missed.">        int sysFlag = PullSysFlag.buildSysFlag(</span>
            commitOffsetEnable, // commitOffset
            true, // suspend
            subExpression != null, // subscription
            classFilter // class filter
        );
        try {
<span class="nc" id="L426">            this.pullAPIWrapper.pullKernelImpl(</span>
<span class="nc" id="L427">                pullRequest.getMessageQueue(),</span>
                subExpression,
<span class="nc" id="L429">                subscriptionData.getExpressionType(),</span>
<span class="nc" id="L430">                subscriptionData.getSubVersion(),</span>
<span class="nc" id="L431">                pullRequest.getNextOffset(),</span>
<span class="nc" id="L432">                this.defaultMQPushConsumer.getPullBatchSize(),</span>
                sysFlag,
                commitOffsetValue,
                BROKER_SUSPEND_MAX_TIME_MILLIS,
                CONSUMER_TIMEOUT_MILLIS_WHEN_SUSPEND,
                CommunicationMode.ASYNC,
                pullCallback
            );
<span class="nc" id="L440">        } catch (Exception e) {</span>
<span class="nc" id="L441">            log.error(&quot;pullKernelImpl exception&quot;, e);</span>
<span class="nc" id="L442">            this.executePullRequestLater(pullRequest, pullTimeDelayMillsWhenException);</span>
<span class="nc" id="L443">        }</span>
<span class="nc" id="L444">    }</span>

    private void makeSureStateOK() throws MQClientException {
<span class="nc bnc" id="L447" title="All 2 branches missed.">        if (this.serviceState != ServiceState.RUNNING) {</span>
<span class="nc" id="L448">            throw new MQClientException(&quot;The consumer service state not OK, &quot;</span>
                + this.serviceState
<span class="nc" id="L450">                + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                null);
        }
<span class="nc" id="L453">    }</span>

    private void executePullRequestLater(final PullRequest pullRequest, final long timeDelay) {
<span class="nc" id="L456">        this.mQClientFactory.getPullMessageService().executePullRequestLater(pullRequest, timeDelay);</span>
<span class="nc" id="L457">    }</span>

    public boolean isPause() {
<span class="nc" id="L460">        return pause;</span>
    }

    public void setPause(boolean pause) {
<span class="nc" id="L464">        this.pause = pause;</span>
<span class="nc" id="L465">    }</span>

    public ConsumerStatsManager getConsumerStatsManager() {
<span class="nc" id="L468">        return this.mQClientFactory.getConsumerStatsManager();</span>
    }

    public void executePullRequestImmediately(final PullRequest pullRequest) {
<span class="nc" id="L472">        this.mQClientFactory.getPullMessageService().executePullRequestImmediately(pullRequest);</span>
<span class="nc" id="L473">    }</span>

    private void correctTagsOffset(final PullRequest pullRequest) {
<span class="nc bnc" id="L476" title="All 2 branches missed.">        if (0L == pullRequest.getProcessQueue().getMsgCount().get()) {</span>
<span class="nc" id="L477">            this.offsetStore.updateOffset(pullRequest.getMessageQueue(), pullRequest.getNextOffset(), true);</span>
        }
<span class="nc" id="L479">    }</span>

    public void executeTaskLater(final Runnable r, final long timeDelay) {
<span class="nc" id="L482">        this.mQClientFactory.getPullMessageService().executeTaskLater(r, timeDelay);</span>
<span class="nc" id="L483">    }</span>

    public QueryResult queryMessage(String topic, String key, int maxNum, long begin, long end)
        throws MQClientException, InterruptedException {
<span class="nc" id="L487">        return this.mQClientFactory.getMQAdminImpl().queryMessage(topic, key, maxNum, begin, end);</span>
    }

    public MessageExt queryMessageByUniqKey(String topic, String uniqKey) throws MQClientException,
        InterruptedException {
<span class="nc" id="L492">        return this.mQClientFactory.getMQAdminImpl().queryMessageByUniqKey(topic, uniqKey);</span>
    }

    public void registerMessageListener(MessageListener messageListener) {
<span class="fc" id="L496">        this.messageListenerInner = messageListener;</span>
<span class="fc" id="L497">    }</span>

    public void resume() {
<span class="nc" id="L500">        this.pause = false;</span>
<span class="nc" id="L501">        doRebalance();</span>
<span class="nc" id="L502">        log.info(&quot;resume this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L503">    }</span>

    public void sendMessageBack(MessageExt msg, int delayLevel, final String brokerName)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
        try {
<span class="nc bnc" id="L508" title="All 2 branches missed.">            String brokerAddr = (null != brokerName) ? this.mQClientFactory.findBrokerAddressInPublish(brokerName)</span>
<span class="nc" id="L509">                : RemotingHelper.parseSocketAddressAddr(msg.getStoreHost());</span>
<span class="nc" id="L510">            this.mQClientFactory.getMQClientAPIImpl().consumerSendMessageBack(brokerAddr, msg,</span>
<span class="nc" id="L511">                this.defaultMQPushConsumer.getConsumerGroup(), delayLevel, 5000, getMaxReconsumeTimes());</span>
<span class="nc" id="L512">        } catch (Exception e) {</span>
<span class="nc" id="L513">            log.error(&quot;sendMessageBack Exception, &quot; + this.defaultMQPushConsumer.getConsumerGroup(), e);</span>

<span class="nc" id="L515">            Message newMsg = new Message(MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup()), msg.getBody());</span>

<span class="nc" id="L517">            String originMsgId = MessageAccessor.getOriginMessageId(msg);</span>
<span class="nc bnc" id="L518" title="All 2 branches missed.">            MessageAccessor.setOriginMessageId(newMsg, UtilAll.isBlank(originMsgId) ? msg.getMsgId() : originMsgId);</span>

<span class="nc" id="L520">            newMsg.setFlag(msg.getFlag());</span>
<span class="nc" id="L521">            MessageAccessor.setProperties(newMsg, msg.getProperties());</span>
<span class="nc" id="L522">            MessageAccessor.putProperty(newMsg, MessageConst.PROPERTY_RETRY_TOPIC, msg.getTopic());</span>
<span class="nc" id="L523">            MessageAccessor.setReconsumeTime(newMsg, String.valueOf(msg.getReconsumeTimes() + 1));</span>
<span class="nc" id="L524">            MessageAccessor.setMaxReconsumeTimes(newMsg, String.valueOf(getMaxReconsumeTimes()));</span>
<span class="nc" id="L525">            MessageAccessor.clearProperty(newMsg, MessageConst.PROPERTY_TRANSACTION_PREPARED);</span>
<span class="nc" id="L526">            newMsg.setDelayTimeLevel(3 + msg.getReconsumeTimes());</span>

<span class="nc" id="L528">            this.mQClientFactory.getDefaultMQProducer().send(newMsg);</span>
        } finally {
<span class="nc" id="L530">            msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));</span>
        }
<span class="nc" id="L532">    }</span>

    private int getMaxReconsumeTimes() {
        // default reconsume times: 16
<span class="nc bnc" id="L536" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getMaxReconsumeTimes() == -1) {</span>
<span class="nc" id="L537">            return 16;</span>
        } else {
<span class="nc" id="L539">            return this.defaultMQPushConsumer.getMaxReconsumeTimes();</span>
        }
    }

    public void shutdown() {
<span class="nc" id="L544">        shutdown(0);</span>
<span class="nc" id="L545">    }</span>

    public synchronized void shutdown(long awaitTerminateMillis) {
<span class="nc bnc" id="L548" title="All 4 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="nc" id="L550">                break;</span>
            case RUNNING:
<span class="nc" id="L552">                this.consumeMessageService.shutdown(awaitTerminateMillis);</span>
<span class="nc" id="L553">                this.persistConsumerOffset();</span>
<span class="nc" id="L554">                this.mQClientFactory.unregisterConsumer(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L555">                this.mQClientFactory.shutdown();</span>
<span class="nc" id="L556">                log.info(&quot;the consumer [{}] shutdown OK&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L557">                this.rebalanceImpl.destroy();</span>
<span class="nc" id="L558">                this.serviceState = ServiceState.SHUTDOWN_ALREADY;</span>
<span class="nc" id="L559">                break;</span>
            case SHUTDOWN_ALREADY:
<span class="nc" id="L561">                break;</span>
            default:
                break;
        }
<span class="nc" id="L565">    }</span>

    public synchronized void start() throws MQClientException {
<span class="pc bpc" id="L568" title="2 of 3 branches missed.">        switch (this.serviceState) {</span>
            case CREATE_JUST:
<span class="fc" id="L570">                log.info(&quot;the consumer [{}] start beginning. messageModel={}, isUnitMode={}&quot;, this.defaultMQPushConsumer.getConsumerGroup(),</span>
<span class="fc" id="L571">                    this.defaultMQPushConsumer.getMessageModel(), this.defaultMQPushConsumer.isUnitMode());</span>
<span class="fc" id="L572">                this.serviceState = ServiceState.START_FAILED;</span>

<span class="nc" id="L574">                this.checkConfig();</span>

<span class="nc" id="L576">                this.copySubscription();</span>

<span class="nc bnc" id="L578" title="All 2 branches missed.">                if (this.defaultMQPushConsumer.getMessageModel() == MessageModel.CLUSTERING) {</span>
<span class="nc" id="L579">                    this.defaultMQPushConsumer.changeInstanceNameToPID();</span>
                }

<span class="nc" id="L582">                this.mQClientFactory = MQClientManager.getInstance().getOrCreateMQClientInstance(this.defaultMQPushConsumer, this.rpcHook);</span>

<span class="nc" id="L584">                this.rebalanceImpl.setConsumerGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L585">                this.rebalanceImpl.setMessageModel(this.defaultMQPushConsumer.getMessageModel());</span>
<span class="nc" id="L586">                this.rebalanceImpl.setAllocateMessageQueueStrategy(this.defaultMQPushConsumer.getAllocateMessageQueueStrategy());</span>
<span class="nc" id="L587">                this.rebalanceImpl.setmQClientFactory(this.mQClientFactory);</span>

<span class="nc" id="L589">                this.pullAPIWrapper = new PullAPIWrapper(</span>
                    mQClientFactory,
<span class="nc" id="L591">                    this.defaultMQPushConsumer.getConsumerGroup(), isUnitMode());</span>
<span class="nc" id="L592">                this.pullAPIWrapper.registerFilterMessageHook(filterMessageHookList);</span>

<span class="nc bnc" id="L594" title="All 2 branches missed.">                if (this.defaultMQPushConsumer.getOffsetStore() != null) {</span>
<span class="nc" id="L595">                    this.offsetStore = this.defaultMQPushConsumer.getOffsetStore();</span>
                } else {
<span class="nc bnc" id="L597" title="All 3 branches missed.">                    switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                        case BROADCASTING:
<span class="nc" id="L599">                            this.offsetStore = new LocalFileOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L600">                            break;</span>
                        case CLUSTERING:
<span class="nc" id="L602">                            this.offsetStore = new RemoteBrokerOffsetStore(this.mQClientFactory, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L603">                            break;</span>
                        default:
                            break;
                    }
<span class="nc" id="L607">                    this.defaultMQPushConsumer.setOffsetStore(this.offsetStore);</span>
                }
<span class="nc" id="L609">                this.offsetStore.load();</span>

<span class="nc bnc" id="L611" title="All 2 branches missed.">                if (this.getMessageListenerInner() instanceof MessageListenerOrderly) {</span>
<span class="nc" id="L612">                    this.consumeOrderly = true;</span>
<span class="nc" id="L613">                    this.consumeMessageService =</span>
<span class="nc" id="L614">                        new ConsumeMessageOrderlyService(this, (MessageListenerOrderly) this.getMessageListenerInner());</span>
<span class="nc bnc" id="L615" title="All 2 branches missed.">                } else if (this.getMessageListenerInner() instanceof MessageListenerConcurrently) {</span>
<span class="nc" id="L616">                    this.consumeOrderly = false;</span>
<span class="nc" id="L617">                    this.consumeMessageService =</span>
<span class="nc" id="L618">                        new ConsumeMessageConcurrentlyService(this, (MessageListenerConcurrently) this.getMessageListenerInner());</span>
                }

<span class="nc" id="L621">                this.consumeMessageService.start();</span>

<span class="nc" id="L623">                boolean registerOK = mQClientFactory.registerConsumer(this.defaultMQPushConsumer.getConsumerGroup(), this);</span>
<span class="nc bnc" id="L624" title="All 2 branches missed.">                if (!registerOK) {</span>
<span class="nc" id="L625">                    this.serviceState = ServiceState.CREATE_JUST;</span>
<span class="nc" id="L626">                    this.consumeMessageService.shutdown(defaultMQPushConsumer.getAwaitTerminationMillisWhenShutdown());</span>
<span class="nc" id="L627">                    throw new MQClientException(&quot;The consumer group[&quot; + this.defaultMQPushConsumer.getConsumerGroup()</span>
<span class="nc" id="L628">                        + &quot;] has been created before, specify another name please.&quot; + FAQUrl.suggestTodo(FAQUrl.GROUP_NAME_DUPLICATE_URL),</span>
                        null);
                }

<span class="nc" id="L632">                mQClientFactory.start();</span>
<span class="nc" id="L633">                log.info(&quot;the consumer [{}] start OK.&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L634">                this.serviceState = ServiceState.RUNNING;</span>
<span class="nc" id="L635">                break;</span>
            case RUNNING:
            case START_FAILED:
            case SHUTDOWN_ALREADY:
<span class="nc" id="L639">                throw new MQClientException(&quot;The PushConsumer service state not OK, maybe started once, &quot;</span>
                    + this.serviceState
<span class="nc" id="L641">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_SERVICE_NOT_OK),</span>
                    null);
            default:
                break;
        }

<span class="nc" id="L647">        this.updateTopicSubscribeInfoWhenSubscriptionChanged();</span>
<span class="nc" id="L648">        this.mQClientFactory.checkClientInBroker();</span>
<span class="nc" id="L649">        this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
<span class="nc" id="L650">        this.mQClientFactory.rebalanceImmediately();</span>
<span class="nc" id="L651">    }</span>

    private void checkConfig() throws MQClientException {
<span class="fc" id="L654">        Validators.checkGroup(this.defaultMQPushConsumer.getConsumerGroup());</span>

<span class="pc bpc" id="L656" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumerGroup()) {</span>
<span class="nc" id="L657">            throw new MQClientException(</span>
                &quot;consumerGroup is null&quot;
<span class="nc" id="L659">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L663" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumerGroup().equals(MixAll.DEFAULT_CONSUMER_GROUP)) {</span>
<span class="nc" id="L664">            throw new MQClientException(</span>
                &quot;consumerGroup can not equal &quot;
                    + MixAll.DEFAULT_CONSUMER_GROUP
                    + &quot;, please specify another one.&quot;
<span class="nc" id="L668">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L672" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageModel()) {</span>
<span class="nc" id="L673">            throw new MQClientException(</span>
                &quot;messageModel is null&quot;
<span class="nc" id="L675">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="pc bpc" id="L679" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getConsumeFromWhere()) {</span>
<span class="nc" id="L680">            throw new MQClientException(</span>
                &quot;consumeFromWhere is null&quot;
<span class="nc" id="L682">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc" id="L686">        Date dt = UtilAll.parseDate(this.defaultMQPushConsumer.getConsumeTimestamp(), UtilAll.YYYYMMDDHHMMSS);</span>
<span class="pc bpc" id="L687" title="1 of 2 branches missed.">        if (null == dt) {</span>
<span class="nc" id="L688">            throw new MQClientException(</span>
                &quot;consumeTimestamp is invalid, the valid format is yyyyMMddHHmmss,but received &quot;
<span class="nc" id="L690">                    + this.defaultMQPushConsumer.getConsumeTimestamp()</span>
<span class="nc" id="L691">                    + &quot; &quot; + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL), null);</span>
        }

        // allocateMessageQueueStrategy
<span class="pc bpc" id="L695" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getAllocateMessageQueueStrategy()) {</span>
<span class="nc" id="L696">            throw new MQClientException(</span>
                &quot;allocateMessageQueueStrategy is null&quot;
<span class="nc" id="L698">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // subscription
<span class="pc bpc" id="L703" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getSubscription()) {</span>
<span class="nc" id="L704">            throw new MQClientException(</span>
                &quot;subscription is null&quot;
<span class="nc" id="L706">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // messageListener
<span class="pc bpc" id="L711" title="1 of 2 branches missed.">        if (null == this.defaultMQPushConsumer.getMessageListener()) {</span>
<span class="nc" id="L712">            throw new MQClientException(</span>
                &quot;messageListener is null&quot;
<span class="nc" id="L714">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="fc" id="L718">        boolean orderly = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerOrderly;</span>
<span class="fc" id="L719">        boolean concurrently = this.defaultMQPushConsumer.getMessageListener() instanceof MessageListenerConcurrently;</span>
<span class="pc bpc" id="L720" title="2 of 4 branches missed.">        if (!orderly &amp;&amp; !concurrently) {</span>
<span class="nc" id="L721">            throw new MQClientException(</span>
                &quot;messageListener must be instanceof MessageListenerOrderly or MessageListenerConcurrently&quot;
<span class="nc" id="L723">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMin
<span class="pc bpc" id="L728" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMin() &lt; 1</span>
<span class="pc bpc" id="L729" title="1 of 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeThreadMin() &gt; 1000) {</span>
<span class="nc" id="L730">            throw new MQClientException(</span>
                &quot;consumeThreadMin Out of range [1, 1000]&quot;
<span class="nc" id="L732">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMax
<span class="pc bpc" id="L737" title="2 of 4 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMax() &lt; 1 || this.defaultMQPushConsumer.getConsumeThreadMax() &gt; 1000) {</span>
<span class="nc" id="L738">            throw new MQClientException(</span>
                &quot;consumeThreadMax Out of range [1, 1000]&quot;
<span class="nc" id="L740">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeThreadMin can't be larger than consumeThreadMax
<span class="pc bpc" id="L745" title="1 of 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeThreadMin() &gt; this.defaultMQPushConsumer.getConsumeThreadMax()) {</span>
<span class="fc" id="L746">            throw new MQClientException(</span>
<span class="fc" id="L747">                &quot;consumeThreadMin (&quot; + this.defaultMQPushConsumer.getConsumeThreadMin() + &quot;) &quot;</span>
<span class="fc" id="L748">                    + &quot;is larger than consumeThreadMax (&quot; + this.defaultMQPushConsumer.getConsumeThreadMax() + &quot;)&quot;,</span>
                null);
        }

        // consumeConcurrentlyMaxSpan
<span class="nc bnc" id="L753" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &lt; 1</span>
<span class="nc bnc" id="L754" title="All 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeConcurrentlyMaxSpan() &gt; 65535) {</span>
<span class="nc" id="L755">            throw new MQClientException(</span>
                &quot;consumeConcurrentlyMaxSpan Out of range [1, 65535]&quot;
<span class="nc" id="L757">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullThresholdForQueue
<span class="nc bnc" id="L762" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdForQueue() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdForQueue() &gt; 65535) {</span>
<span class="nc" id="L763">            throw new MQClientException(</span>
                &quot;pullThresholdForQueue Out of range [1, 65535]&quot;
<span class="nc" id="L765">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullThresholdForTopic
<span class="nc bnc" id="L770" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdForTopic() != -1) {</span>
<span class="nc bnc" id="L771" title="All 4 branches missed.">            if (this.defaultMQPushConsumer.getPullThresholdForTopic() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdForTopic() &gt; 6553500) {</span>
<span class="nc" id="L772">                throw new MQClientException(</span>
                    &quot;pullThresholdForTopic Out of range [1, 6553500]&quot;
<span class="nc" id="L774">                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                    null);
            }
        }

        // pullThresholdSizeForQueue
<span class="nc bnc" id="L780" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdSizeForQueue() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdSizeForQueue() &gt; 1024) {</span>
<span class="nc" id="L781">            throw new MQClientException(</span>
                &quot;pullThresholdSizeForQueue Out of range [1, 1024]&quot;
<span class="nc" id="L783">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

<span class="nc bnc" id="L787" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() != -1) {</span>
            // pullThresholdSizeForTopic
<span class="nc bnc" id="L789" title="All 4 branches missed.">            if (this.defaultMQPushConsumer.getPullThresholdSizeForTopic() &lt; 1 || this.defaultMQPushConsumer.getPullThresholdSizeForTopic() &gt; 102400) {</span>
<span class="nc" id="L790">                throw new MQClientException(</span>
                    &quot;pullThresholdSizeForTopic Out of range [1, 102400]&quot;
<span class="nc" id="L792">                        + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                    null);
            }
        }

        // pullInterval
<span class="nc bnc" id="L798" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullInterval() &lt; 0 || this.defaultMQPushConsumer.getPullInterval() &gt; 65535) {</span>
<span class="nc" id="L799">            throw new MQClientException(</span>
                &quot;pullInterval Out of range [0, 65535]&quot;
<span class="nc" id="L801">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // consumeMessageBatchMaxSize
<span class="nc bnc" id="L806" title="All 2 branches missed.">        if (this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &lt; 1</span>
<span class="nc bnc" id="L807" title="All 2 branches missed.">            || this.defaultMQPushConsumer.getConsumeMessageBatchMaxSize() &gt; 1024) {</span>
<span class="nc" id="L808">            throw new MQClientException(</span>
                &quot;consumeMessageBatchMaxSize Out of range [1, 1024]&quot;
<span class="nc" id="L810">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }

        // pullBatchSize
<span class="nc bnc" id="L815" title="All 4 branches missed.">        if (this.defaultMQPushConsumer.getPullBatchSize() &lt; 1 || this.defaultMQPushConsumer.getPullBatchSize() &gt; 1024) {</span>
<span class="nc" id="L816">            throw new MQClientException(</span>
                &quot;pullBatchSize Out of range [1, 1024]&quot;
<span class="nc" id="L818">                    + FAQUrl.suggestTodo(FAQUrl.CLIENT_PARAMETER_CHECK_URL),</span>
                null);
        }
<span class="nc" id="L821">    }</span>

    private void copySubscription() throws MQClientException {
        try {
<span class="nc" id="L825">            Map&lt;String, String&gt; sub = this.defaultMQPushConsumer.getSubscription();</span>
<span class="nc bnc" id="L826" title="All 2 branches missed.">            if (sub != null) {</span>
<span class="nc bnc" id="L827" title="All 2 branches missed.">                for (final Map.Entry&lt;String, String&gt; entry : sub.entrySet()) {</span>
<span class="nc" id="L828">                    final String topic = entry.getKey();</span>
<span class="nc" id="L829">                    final String subString = entry.getValue();</span>
<span class="nc" id="L830">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),</span>
                        topic, subString);
<span class="nc" id="L832">                    this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc" id="L833">                }</span>
            }

<span class="nc bnc" id="L836" title="All 2 branches missed.">            if (null == this.messageListenerInner) {</span>
<span class="nc" id="L837">                this.messageListenerInner = this.defaultMQPushConsumer.getMessageListener();</span>
            }

<span class="nc bnc" id="L840" title="All 3 branches missed.">            switch (this.defaultMQPushConsumer.getMessageModel()) {</span>
                case BROADCASTING:
<span class="nc" id="L842">                    break;</span>
                case CLUSTERING:
<span class="nc" id="L844">                    final String retryTopic = MixAll.getRetryTopic(this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L845">                    SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),</span>
                        retryTopic, SubscriptionData.SUB_ALL);
<span class="nc" id="L847">                    this.rebalanceImpl.getSubscriptionInner().put(retryTopic, subscriptionData);</span>
<span class="nc" id="L848">                    break;</span>
                default:
                    break;
            }
<span class="nc" id="L852">        } catch (Exception e) {</span>
<span class="nc" id="L853">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L854">        }</span>
<span class="nc" id="L855">    }</span>

    public MessageListener getMessageListenerInner() {
<span class="nc" id="L858">        return messageListenerInner;</span>
    }

    private void updateTopicSubscribeInfoWhenSubscriptionChanged() {
<span class="nc" id="L862">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L863" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L864" title="All 2 branches missed.">            for (final Map.Entry&lt;String, SubscriptionData&gt; entry : subTable.entrySet()) {</span>
<span class="nc" id="L865">                final String topic = entry.getKey();</span>
<span class="nc" id="L866">                this.mQClientFactory.updateTopicRouteInfoFromNameServer(topic);</span>
<span class="nc" id="L867">            }</span>
        }
<span class="nc" id="L869">    }</span>

    public ConcurrentMap&lt;String, SubscriptionData&gt; getSubscriptionInner() {
<span class="nc" id="L872">        return this.rebalanceImpl.getSubscriptionInner();</span>
    }

    public void subscribe(String topic, String subExpression) throws MQClientException {
        try {
<span class="nc" id="L877">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),</span>
                topic, subExpression);
<span class="nc" id="L879">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L880" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L881">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }
<span class="nc" id="L883">        } catch (Exception e) {</span>
<span class="nc" id="L884">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L885">        }</span>
<span class="nc" id="L886">    }</span>

    public void subscribe(String topic, String fullClassName, String filterClassSource) throws MQClientException {
        try {
<span class="nc" id="L890">            SubscriptionData subscriptionData = FilterAPI.buildSubscriptionData(this.defaultMQPushConsumer.getConsumerGroup(),</span>
                topic, &quot;*&quot;);
<span class="nc" id="L892">            subscriptionData.setSubString(fullClassName);</span>
<span class="nc" id="L893">            subscriptionData.setClassFilterMode(true);</span>
<span class="nc" id="L894">            subscriptionData.setFilterClassSource(filterClassSource);</span>
<span class="nc" id="L895">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L896" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L897">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }

<span class="nc" id="L900">        } catch (Exception e) {</span>
<span class="nc" id="L901">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L902">        }</span>
<span class="nc" id="L903">    }</span>

    public void subscribe(final String topic, final MessageSelector messageSelector) throws MQClientException {
        try {
<span class="nc bnc" id="L907" title="All 2 branches missed.">            if (messageSelector == null) {</span>
<span class="nc" id="L908">                subscribe(topic, SubscriptionData.SUB_ALL);</span>
<span class="nc" id="L909">                return;</span>
            }

<span class="nc" id="L912">            SubscriptionData subscriptionData = FilterAPI.build(topic,</span>
<span class="nc" id="L913">                messageSelector.getExpression(), messageSelector.getExpressionType());</span>

<span class="nc" id="L915">            this.rebalanceImpl.getSubscriptionInner().put(topic, subscriptionData);</span>
<span class="nc bnc" id="L916" title="All 2 branches missed.">            if (this.mQClientFactory != null) {</span>
<span class="nc" id="L917">                this.mQClientFactory.sendHeartbeatToAllBrokerWithLock();</span>
            }
<span class="nc" id="L919">        } catch (Exception e) {</span>
<span class="nc" id="L920">            throw new MQClientException(&quot;subscription exception&quot;, e);</span>
<span class="nc" id="L921">        }</span>
<span class="nc" id="L922">    }</span>

    public void suspend() {
<span class="nc" id="L925">        this.pause = true;</span>
<span class="nc" id="L926">        log.info(&quot;suspend this consumer, {}&quot;, this.defaultMQPushConsumer.getConsumerGroup());</span>
<span class="nc" id="L927">    }</span>

    public void unsubscribe(String topic) {
<span class="nc" id="L930">        this.rebalanceImpl.getSubscriptionInner().remove(topic);</span>
<span class="nc" id="L931">    }</span>

    public void updateConsumeOffset(MessageQueue mq, long offset) {
<span class="nc" id="L934">        this.offsetStore.updateOffset(mq, offset, false);</span>
<span class="nc" id="L935">    }</span>

    public void updateCorePoolSize(int corePoolSize) {
<span class="nc" id="L938">        this.consumeMessageService.updateCorePoolSize(corePoolSize);</span>
<span class="nc" id="L939">    }</span>

    public MessageExt viewMessage(String msgId)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc" id="L943">        return this.mQClientFactory.getMQAdminImpl().viewMessage(msgId);</span>
    }

    public RebalanceImpl getRebalanceImpl() {
<span class="nc" id="L947">        return rebalanceImpl;</span>
    }

    public boolean isConsumeOrderly() {
<span class="nc" id="L951">        return consumeOrderly;</span>
    }

    public void setConsumeOrderly(boolean consumeOrderly) {
<span class="nc" id="L955">        this.consumeOrderly = consumeOrderly;</span>
<span class="nc" id="L956">    }</span>

    public void resetOffsetByTimeStamp(long timeStamp)
        throws RemotingException, MQBrokerException, InterruptedException, MQClientException {
<span class="nc bnc" id="L960" title="All 2 branches missed.">        for (String topic : rebalanceImpl.getSubscriptionInner().keySet()) {</span>
<span class="nc" id="L961">            Set&lt;MessageQueue&gt; mqs = rebalanceImpl.getTopicSubscribeInfoTable().get(topic);</span>
<span class="nc" id="L962">            Map&lt;MessageQueue, Long&gt; offsetTable = new HashMap&lt;MessageQueue, Long&gt;();</span>
<span class="nc bnc" id="L963" title="All 2 branches missed.">            if (mqs != null) {</span>
<span class="nc bnc" id="L964" title="All 2 branches missed.">                for (MessageQueue mq : mqs) {</span>
<span class="nc" id="L965">                    long offset = searchOffset(mq, timeStamp);</span>
<span class="nc" id="L966">                    offsetTable.put(mq, offset);</span>
<span class="nc" id="L967">                }</span>
<span class="nc" id="L968">                this.mQClientFactory.resetOffset(topic, groupName(), offsetTable);</span>
            }
<span class="nc" id="L970">        }</span>
<span class="nc" id="L971">    }</span>

    public long searchOffset(MessageQueue mq, long timestamp) throws MQClientException {
<span class="nc" id="L974">        return this.mQClientFactory.getMQAdminImpl().searchOffset(mq, timestamp);</span>
    }

    @Override
    public String groupName() {
<span class="nc" id="L979">        return this.defaultMQPushConsumer.getConsumerGroup();</span>
    }

    @Override
    public MessageModel messageModel() {
<span class="nc" id="L984">        return this.defaultMQPushConsumer.getMessageModel();</span>
    }

    @Override
    public ConsumeType consumeType() {
<span class="nc" id="L989">        return ConsumeType.CONSUME_PASSIVELY;</span>
    }

    @Override
    public ConsumeFromWhere consumeFromWhere() {
<span class="nc" id="L994">        return this.defaultMQPushConsumer.getConsumeFromWhere();</span>
    }

    @Override
    public Set&lt;SubscriptionData&gt; subscriptions() {
<span class="fc" id="L999">        Set&lt;SubscriptionData&gt; subSet = new HashSet&lt;SubscriptionData&gt;();</span>

<span class="fc" id="L1001">        subSet.addAll(this.rebalanceImpl.getSubscriptionInner().values());</span>

<span class="fc" id="L1003">        return subSet;</span>
    }

    @Override
    public void doRebalance() {
<span class="nc bnc" id="L1008" title="All 2 branches missed.">        if (!this.pause) {</span>
<span class="nc" id="L1009">            this.rebalanceImpl.doRebalance(this.isConsumeOrderly());</span>
        }
<span class="nc" id="L1011">    }</span>

    @Override
    public void persistConsumerOffset() {
        try {
<span class="nc" id="L1016">            this.makeSureStateOK();</span>
<span class="nc" id="L1017">            Set&lt;MessageQueue&gt; mqs = new HashSet&lt;MessageQueue&gt;();</span>
<span class="nc" id="L1018">            Set&lt;MessageQueue&gt; allocateMq = this.rebalanceImpl.getProcessQueueTable().keySet();</span>
<span class="nc" id="L1019">            mqs.addAll(allocateMq);</span>

<span class="nc" id="L1021">            this.offsetStore.persistAll(mqs);</span>
<span class="nc" id="L1022">        } catch (Exception e) {</span>
<span class="nc" id="L1023">            log.error(&quot;group: &quot; + this.defaultMQPushConsumer.getConsumerGroup() + &quot; persistConsumerOffset exception&quot;, e);</span>
<span class="nc" id="L1024">        }</span>
<span class="nc" id="L1025">    }</span>

    @Override
    public void updateTopicSubscribeInfo(String topic, Set&lt;MessageQueue&gt; info) {
<span class="nc" id="L1029">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L1030" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1031" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc" id="L1032">                this.rebalanceImpl.topicSubscribeInfoTable.put(topic, info);</span>
            }
        }
<span class="nc" id="L1035">    }</span>

    @Override
    public boolean isSubscribeTopicNeedUpdate(String topic) {
<span class="nc" id="L1039">        Map&lt;String, SubscriptionData&gt; subTable = this.getSubscriptionInner();</span>
<span class="nc bnc" id="L1040" title="All 2 branches missed.">        if (subTable != null) {</span>
<span class="nc bnc" id="L1041" title="All 2 branches missed.">            if (subTable.containsKey(topic)) {</span>
<span class="nc bnc" id="L1042" title="All 2 branches missed.">                return !this.rebalanceImpl.topicSubscribeInfoTable.containsKey(topic);</span>
            }
        }

<span class="nc" id="L1046">        return false;</span>
    }

    @Override
    public boolean isUnitMode() {
<span class="nc" id="L1051">        return this.defaultMQPushConsumer.isUnitMode();</span>
    }

    @Override
    public ConsumerRunningInfo consumerRunningInfo() {
<span class="fc" id="L1056">        ConsumerRunningInfo info = new ConsumerRunningInfo();</span>

<span class="fc" id="L1058">        Properties prop = MixAll.object2Properties(this.defaultMQPushConsumer);</span>

<span class="fc" id="L1060">        prop.put(ConsumerRunningInfo.PROP_CONSUME_ORDERLY, String.valueOf(this.consumeOrderly));</span>
<span class="fc" id="L1061">        prop.put(ConsumerRunningInfo.PROP_THREADPOOL_CORE_SIZE, String.valueOf(this.consumeMessageService.getCorePoolSize()));</span>
<span class="fc" id="L1062">        prop.put(ConsumerRunningInfo.PROP_CONSUMER_START_TIMESTAMP, String.valueOf(this.consumerStartTimestamp));</span>

<span class="fc" id="L1064">        info.setProperties(prop);</span>

<span class="fc" id="L1066">        Set&lt;SubscriptionData&gt; subSet = this.subscriptions();</span>
<span class="fc" id="L1067">        info.getSubscriptionSet().addAll(subSet);</span>

<span class="fc" id="L1069">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = this.rebalanceImpl.getProcessQueueTable().entrySet().iterator();</span>
<span class="pc bpc" id="L1070" title="1 of 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1071">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L1072">            MessageQueue mq = next.getKey();</span>
<span class="nc" id="L1073">            ProcessQueue pq = next.getValue();</span>

<span class="nc" id="L1075">            ProcessQueueInfo pqinfo = new ProcessQueueInfo();</span>
<span class="nc" id="L1076">            pqinfo.setCommitOffset(this.offsetStore.readOffset(mq, ReadOffsetType.MEMORY_FIRST_THEN_STORE));</span>
<span class="nc" id="L1077">            pq.fillProcessQueueInfo(pqinfo);</span>
<span class="nc" id="L1078">            info.getMqTable().put(mq, pqinfo);</span>
<span class="nc" id="L1079">        }</span>

<span class="pc bpc" id="L1081" title="1 of 2 branches missed.">        for (SubscriptionData sd : subSet) {</span>
<span class="nc" id="L1082">            ConsumeStatus consumeStatus = this.mQClientFactory.getConsumerStatsManager().consumeStatus(this.groupName(), sd.getTopic());</span>
<span class="nc" id="L1083">            info.getStatusTable().put(sd.getTopic(), consumeStatus);</span>
<span class="nc" id="L1084">        }</span>

<span class="fc" id="L1086">        return info;</span>
    }

    public MQClientInstance getmQClientFactory() {
<span class="nc" id="L1090">        return mQClientFactory;</span>
    }

    public void setmQClientFactory(MQClientInstance mQClientFactory) {
<span class="nc" id="L1094">        this.mQClientFactory = mQClientFactory;</span>
<span class="nc" id="L1095">    }</span>

    public ServiceState getServiceState() {
<span class="nc" id="L1098">        return serviceState;</span>
    }

    //Don't use this deprecated setter, which will be removed soon.
    @Deprecated
    public synchronized void setServiceState(ServiceState serviceState) {
<span class="nc" id="L1104">        this.serviceState = serviceState;</span>
<span class="nc" id="L1105">    }</span>

    public void adjustThreadPool() {
<span class="nc" id="L1108">        long computeAccTotal = this.computeAccumulationTotal();</span>
<span class="nc" id="L1109">        long adjustThreadPoolNumsThreshold = this.defaultMQPushConsumer.getAdjustThreadPoolNumsThreshold();</span>

<span class="nc" id="L1111">        long incThreshold = (long) (adjustThreadPoolNumsThreshold * 1.0);</span>

<span class="nc" id="L1113">        long decThreshold = (long) (adjustThreadPoolNumsThreshold * 0.8);</span>

<span class="nc bnc" id="L1115" title="All 2 branches missed.">        if (computeAccTotal &gt;= incThreshold) {</span>
<span class="nc" id="L1116">            this.consumeMessageService.incCorePoolSize();</span>
        }

<span class="nc bnc" id="L1119" title="All 2 branches missed.">        if (computeAccTotal &lt; decThreshold) {</span>
<span class="nc" id="L1120">            this.consumeMessageService.decCorePoolSize();</span>
        }
<span class="nc" id="L1122">    }</span>

    private long computeAccumulationTotal() {
<span class="nc" id="L1125">        long msgAccTotal = 0;</span>
<span class="nc" id="L1126">        ConcurrentMap&lt;MessageQueue, ProcessQueue&gt; processQueueTable = this.rebalanceImpl.getProcessQueueTable();</span>
<span class="nc" id="L1127">        Iterator&lt;Entry&lt;MessageQueue, ProcessQueue&gt;&gt; it = processQueueTable.entrySet().iterator();</span>
<span class="nc bnc" id="L1128" title="All 2 branches missed.">        while (it.hasNext()) {</span>
<span class="nc" id="L1129">            Entry&lt;MessageQueue, ProcessQueue&gt; next = it.next();</span>
<span class="nc" id="L1130">            ProcessQueue value = next.getValue();</span>
<span class="nc" id="L1131">            msgAccTotal += value.getMsgAccCnt();</span>
<span class="nc" id="L1132">        }</span>

<span class="nc" id="L1134">        return msgAccTotal;</span>
    }

    public List&lt;QueueTimeSpan&gt; queryConsumeTimeSpan(final String topic)
        throws RemotingException, MQClientException, InterruptedException, MQBrokerException {
<span class="nc" id="L1139">        List&lt;QueueTimeSpan&gt; queueTimeSpan = new ArrayList&lt;QueueTimeSpan&gt;();</span>
<span class="nc" id="L1140">        TopicRouteData routeData = this.mQClientFactory.getMQClientAPIImpl().getTopicRouteInfoFromNameServer(topic, 3000);</span>
<span class="nc bnc" id="L1141" title="All 2 branches missed.">        for (BrokerData brokerData : routeData.getBrokerDatas()) {</span>
<span class="nc" id="L1142">            String addr = brokerData.selectBrokerAddr();</span>
<span class="nc" id="L1143">            queueTimeSpan.addAll(this.mQClientFactory.getMQClientAPIImpl().queryConsumeTimeSpan(addr, topic, groupName(), 3000));</span>
<span class="nc" id="L1144">        }</span>

<span class="nc" id="L1146">        return queueTimeSpan;</span>
    }

    public void resetRetryAndNamespace(final List&lt;MessageExt&gt; msgs, String consumerGroup) {
<span class="fc" id="L1150">        final String groupTopic = MixAll.getRetryTopic(consumerGroup);</span>
<span class="fc bfc" id="L1151" title="All 2 branches covered.">        for (MessageExt msg : msgs) {</span>
<span class="fc" id="L1152">            String retryTopic = msg.getProperty(MessageConst.PROPERTY_RETRY_TOPIC);</span>
<span class="pc bpc" id="L1153" title="3 of 4 branches missed.">            if (retryTopic != null &amp;&amp; groupTopic.equals(msg.getTopic())) {</span>
<span class="nc" id="L1154">                msg.setTopic(retryTopic);</span>
            }

<span class="pc bpc" id="L1157" title="1 of 2 branches missed.">            if (StringUtils.isNotEmpty(this.defaultMQPushConsumer.getNamespace())) {</span>
<span class="nc" id="L1158">                msg.setTopic(NamespaceUtil.withoutNamespace(msg.getTopic(), this.defaultMQPushConsumer.getNamespace()));</span>
            }
<span class="fc" id="L1160">        }</span>
<span class="fc" id="L1161">    }</span>

    public ConsumeMessageService getConsumeMessageService() {
<span class="nc" id="L1164">        return consumeMessageService;</span>
    }

    public void setConsumeMessageService(ConsumeMessageService consumeMessageService) {
<span class="fc" id="L1168">        this.consumeMessageService = consumeMessageService;</span>

<span class="fc" id="L1170">    }</span>

    public void setPullTimeDelayMillsWhenException(long pullTimeDelayMillsWhenException) {
<span class="nc" id="L1173">        this.pullTimeDelayMillsWhenException = pullTimeDelayMillsWhenException;</span>
<span class="nc" id="L1174">    }</span>
}
</pre><div class="footer"><span class="right">Created with <a href="http://www.jacoco.org/jacoco">JaCoCo</a> 0.8.5.201910111838</span></div></body></html>